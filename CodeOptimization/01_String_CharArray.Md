Great question ğŸ‘Œ Letâ€™s carefully analyze both functions.

---

### ğŸ“Œ Function 1

```c
char* fn1()
{	
    char *str = "Hello World";
    return str;
}
```

* Here `str` is a **pointer to a string literal** `"Hello World"`.
* String literals are stored in **read-only memory** (in `.rodata` section).
* When you `return str;`, you are returning the pointer to that **valid memory**.
* âœ… So `fn1()` returns a valid pointer to `"Hello World"`.

---

### ğŸ“Œ Function 2

```c
char* fn2()
{
    char str[] = "Hello World";
    return str;
}
```

* Here `str` is a **local array** inside the function.
* Its storage is on the **stack frame of fn2()**.
* Once the function exits, the stack frame is destroyed â†’ memory for `str` is invalid.
* âŒ Returning `str` gives a **dangling pointer** (undefined behavior if accessed).

---

### âœ… Conclusion

* `fn1()` â†’ **Returns a valid address** (string literal in static memory).
* `fn2()` â†’ **Returns an invalid address** (local array on stack, freed after function returns).

---

âš ï¸ Small note: In `fn1()`, the returned pointer is valid but the string literal should **not be modified** (e.g., `*str = 'h';` â†’ undefined behavior).

ğŸ‘‰ Do you want me to also show what happens in **assembly/memory layout** for both cases (so you can use it in an interview whiteboard explanation)?
